import loggingfrom django.contrib.auth.models import Userfrom ..models import Events, Recordsfrom django.db.utils import IntegrityErrorimport datetimefrom celery import groupfrom ..tasks import (    task_create_reminder_for_user_one_hour, task_create_reminder_for_user_three_hours,    task_create_reminder_for_user_twelve_hours)logger = logging.getLogger(__name__)logger.setLevel(level=logging.INFO)handler = logging.FileHandler(    filename=f"app.log", encoding='UTF-8')formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")handler.setFormatter(formatter)logger.addHandler(handler)class Result:    def __init__(self, exception: Exception = None, **kwargs):        self.exception = exception        self.kwargs = kwargs if kwargs else None    def __getattr__(self, attr):        match attr:            case 'error':                return self._error            case _:                return self.__dict__[attr]    def __setattr__(self, attr, value):        match attr:            case 'exception':                if isinstance(value, Exception):                    self.__dict__.update({                        'is_error': True,                        'is_success': False,                        '_error': value                    })            case _:                if isinstance(value, dict):                    error = self.__dict__.get('is_error')                    if error:                        self.__dict__.update({                            **value                        })                    else:                        self.__dict__.update({                            'is_success': True,                            'is_error': False,                            **value                        })    def __or__(self, other):        kwargs = self.__dict__        return other(**kwargs)    def write_to_logs(self):        passclass Task:    passclass ServiceObject:    def __init__(self):        self.result = Result        self.task = Task    def service_success(self, **success) -> 'Result':        result = self.result(**success)        return result    def service_error(self, exception: Exception) -> 'Result':        result = self.result(exception=exception)        return result    def services_result(self, exception: Exception = None, **kwargs):        return self.result(exception, **kwargs)    def create_task(selr, date: 'datetime', event_id: int):        logger.info('date: {}, event_id: {}'.format(date, event_id))        reminder_one = task_create_reminder_for_user_one_hour        reminder_three = task_create_reminder_for_user_three_hours        reminder_twelve = task_create_reminder_for_user_twelve_hours        reminder_group = group([            reminder_one.si(date=date, event_id=event_id),            reminder_three.si(date=date, event_id=event_id),            reminder_twelve.si(date=date, event_id=event_id)        ])        result = reminder_group()        result.get()class EventGetService(ServiceObject):    def get_event(self, event_id: int) -> 'Result':        try:            event = _get_event_from_db(event_id=event_id)        except Events.DoesNotExist as exc:            return self.service_error(exception=exc)        else:            return self.service_success(event=event)    def __call__(self, event_id: int):        return self.get_event(event_id=event_id)def _get_event_from_db(event_id: int):    return Events.objects.get(id=event_id)class EventPostService(ServiceObject):    def create_event(self, name: str, date: str) -> 'Result':        try:            event = _create_event_in_db(name=name, date=date)        except IntegrityError as exc:            return self.services_result(exception=exc)        else:            self.create_task(date=date, event_id=event.id)            return self.services_result(event=event)    def __call__(self, name: str, date: str):        return self.create_event(name=name, date=date)def _create_event_in_db(name: str, date: str):    event = Events.objects.create(name=name, date=date)    return eventclass UserGetService(ServiceObject):    def get_user(self, user_id: int) -> 'Result':        try:            user = User.objects.get(id=user_id)        except User.DoesNotExist as exc:            return self.service_error(exception=exc)        else:            return self.service_success(user=user)    def __call__(self, user_id: int) -> 'Result':        return self.get_user(user_id=user_id)class RecordPostService(ServiceObject):    def __init__(self):        super().__init__()        self.get_event = EventGetService()        self.get_user = UserGetService()    def _get_user(self, user_id: int, **kwargs):        user_object_result = self.get_user(user_id=user_id)        if user_object_result.is_error:            kwargs.update(user_object_result.__dict__)        if user_object_result.is_success:            kwargs['user'] = user_object_result.user        return self.services_result(**kwargs)    def _get_event(self, event_id: int, **kwargs):        if not kwargs['is_error']:            event_object_result = self.get_event(event_id=event_id)            if event_object_result.is_error:                kwargs.update(event_object_result.__dict__)            if event_object_result.is_success:                kwargs['event'] = event_object_result.event        return self.services_result(**kwargs)    def create_record(self, **kwargs):        user = kwargs.get('user')        event = kwargs.get('event')        if user and event:            record = _create_record_in_db(**kwargs)            kwargs['record'] = record        return self.services_result(**kwargs)    def __call__(self, **kwargs):        return (self.service_success(**kwargs) |                self._get_user |                self._get_event |                self.create_record)def _create_record_in_db(user: 'User', event: 'Events', reminder_time: int, **kwargs):    record = Records.objects.create(user=user, event=event, reminder_time=reminder_time)    return record